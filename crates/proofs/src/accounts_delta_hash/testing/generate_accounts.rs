use std::collections::{BTreeSet, HashSet};

use solana_accounts_db::{
    accounts_db::AccountsDb,
    accounts_hash::{AccountHash, AccountsHasher},
};
use solana_sdk::{account::Account, pubkey::Pubkey};

use crate::accounts_delta_hash::{
    AccountMerkleTree,
    testing::{ArbAccount, ArbKeypair},
};

/// Wrapper type for the data generated by [`generate_accounts`].
pub struct TestAccounts {
    /// The accounts which are present in the accounts_delta_hash.
    pub accounts: Vec<(ArbKeypair, ArbAccount)>,

    /// A merkle tree containing all updated accounts for a slot.
    /// `levels[0]` contains the leaves, and `levels[levels.len()-1][0]` contains the root.
    ///
    /// Created by our code.
    pub tree: AccountMerkleTree,

    /// The accounts_delta_hash, matching what's computed by the Solana validators.
    /// This is verified to be equal to the root of the merkle tree.
    ///
    /// Created using Solana's [`solana_accounts_db::accounts_hash::AccountsHasher`].
    pub accounts_delta_hash: solana_sdk::hash::Hash,
}

/// Generates a set of accounts and the merkle tree that proves their inclusion in the accounts_delta_hash.
pub fn generate_accounts(
    u: &mut arbitrary::Unstructured,
    important_pubkeys: BTreeSet<Pubkey>,
    always_included_accounts: Vec<(ArbKeypair, ArbAccount)>,
) -> Result<TestAccounts, arbitrary::Error> {
    let mut accounts: Vec<(ArbKeypair, ArbAccount)> = if u.ratio(1, 4)? {
        // This is biased towards smallers lists (< 10), but often that's good for minimization.
        u.arbitrary()?
    } else {
        // This generates much larger lists (> 100), but considering the merkle fanout is 16 it's
        // necessary in order to get multiple levels in the tree.
        let len = u.arbitrary_len::<(ArbKeypair, ArbAccount)>()?;
        std::iter::from_fn(|| Some(u.arbitrary()))
            .take(len)
            .collect::<Result<HashSet<_>, _>>()?
            .into_iter()
            .collect()
    };
    for (keypair, account) in always_included_accounts {
        accounts.push((keypair, account));
    }

    // The accounts need to be sorted by pubkey according to the `AccountsDb` implementation,
    // but this is also what lets us implement cheaper exclusion proofs in the first place.
    accounts.sort_by_key(|(keypair, _)| keypair.pubkey());

    let mut solana_accounts: Vec<(Pubkey, Account)> = accounts
        .iter()
        .map(|(keypair, account)| (keypair.pubkey(), account.clone().into()))
        .collect();
    let hashes: Vec<(Pubkey, AccountHash)> = solana_accounts
        .iter()
        .map(|(pubkey, account)| (*pubkey, AccountsDb::hash_account(account, pubkey)))
        .collect();

    // This is the official root computed by Solana validators, considered a source of truth when proving.
    let accounts_delta_hash = AccountsHasher::accumulate_account_hashes(hashes.clone());

    // This is the complete merkle tree, used to construct the proofs.
    let mut tree_builder = AccountMerkleTree::builder(important_pubkeys);

    // Insert the accounts in a random order to traverse more code paths.
    while !solana_accounts.is_empty() {
        let (pubkey, account) = u.choose(&solana_accounts)?.clone();
        tree_builder.insert(pubkey, account);

        // Almost always remove the account from the list, but sometimes leave it in
        // to verify that double insertions of the same key works.
        if u.ratio(9, 10)? {
            solana_accounts.retain(|(p, _)| p != &pubkey);
        }
    }
    let tree = tree_builder.build();

    // Sanity check.
    assert_eq!(tree.root(), accounts_delta_hash);

    Ok(TestAccounts {
        accounts,
        accounts_delta_hash,
        tree,
    })
}
